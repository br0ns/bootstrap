#!/bin/bash

# Where in the world is bootstrap?
BOOTSTRAP_ARCHIVE="https://github.com/br0ns/bootstrap/archive/master.zip"

# Bail on any error
set -e

# This is a hack: I'm using aliases to parse line numbers around
shopt -s expand_aliases
alias assert='__assert $LINENO'
alias run='__run $LINENO'

# Are we being sourced or run directly?

if [ "$0" = "$BASH_SOURCE" ] && [ ! "$BOOTSTRAP_SOURCED" = true ] ; then
    # We're run directly

    # The bootstrap repository has a .repository file.  If that file does not
    # exist it's probably because we're bootstrapping a fresh system.  So we
    # download the git repository and bootstrap from there
    if [ ! -e "$(dirname "$0")/.repository" ] ; then
        # Might as well use all the nice utility functions below

        # Avoid infinite loop
        BOOTSTRAP_SOURCED=true
        source "$0"
        goto_tempdir

        if [ "$SIMULATE" = true ] ; then
            ERR "This is a simulation; not going to fetch archive"
            exit 1
        fi

        INFO Downloading Bootstrap GIT archive
        run wget "$BOOTSTRAP_ARCHIVE"
        run unzip bootstrap-master.zip
        INFO "Here goes"
        echo
        bootstrap-master/bootstrap "$@"
        exit
    fi

    # At this point we know that we're being run directly and is located in the
    # git repository;  Go through all the step scripts and execute them

    for f in "$(dirname "$0")"/* ; do
        # Path must be an executable (-x) file (-f) which starts with a digit
        [[ "$(basename "$f")" =~ ^[0-9] ]] && \
            [ -f "$f" ] && [ -x "$f" ] || continue
        "$f" "$@"
    done

    echo ALL DONE
    exit 0
fi

# We're being sourced by one of the bootstrap steps (or ourselves)

# Parse command line options
SIMULATE=false
ASK_STEP=false
VERBOSE=true
while getopts "hsaq" OPTION ; do
    case $OPTION in
        h) echo "usage: $(basename "$0") [-h] [-s] [-a] [-q]"
           echo "  -h Help"
           echo "  -s Simulate"
           echo "  -a Ask before each step"
           echo "  -q Quiet"
           exit 1
           ;;
        s) SIMULATE=true
           ;;
        a) ASK_STEP=true
           ;;
        q) VERBOSE=false
           ;;
    esac
done

# Utility functions

# Commands should be prefixed with "run" to get logging and error messages
function __run () {
    lineno=$1
    shift
    if [ "$VERBOSE" = true ] ; then
        echo -e "\x1b[35m+\x1b[m $@"
    fi
    if [ ! "$SIMULATE" = true ] ; then
        if [ "$VERBOSE" = true ] ; then
            eval $@
        else
            eval $@ >/dev/null 2>&1
        fi
    fi || __finish $lineno
}

function __assert () {
    lineno=$1
    shift
    if ! eval "$@" ; then
        ERR "ASSERTION FAILED <$0:$lineno>:"
        echo "  $@"
        exit 1
    fi
}

# Set up an exit handler
function __finish () {
    status=$?
    [ "$__ERROR" = true ] && exit 1
    if [ $status -eq 0 ] ; then
        echo DONE
        echo
        exit 0
    else
        __ERROR=true
        lineno=$1
        shift
        ERR "FAILED (exit code $status) <$(basename "$STEP_FILE"):$lineno>:"
        echo "  $(tail "$STEP_FILE" -n +$lineno|head -n 1)"
        exit 1
    fi
}
# LINENO only works for ERR
trap "__finish \${LINENO}" ERR
trap "__finish" EXIT

function promptyn () {
    if [ $# -eq 2 ] ; then
        if [ $2 == "y" ] ; then
            p="[Y/n]"
        else
            p="[y/N]"
        fi
    else
        p="[y/n]"
    fi
    while true; do
        echo -n "$1 $p "
        read yn
        if [ "x$yn" == "xy" ] || \
               [ "x$yn" == "xyes" ] || \
               [ "x$yn" == "xY" ] || \
               [ "x$yn" == "xYes" ] || \
               [ "x$yn" == "xYES" ] || \
               [[ "x$yn" == "x" && $# -eq 2 && $2 == "y" ]] ; then
            return 0
        fi
        if [ "x$yn" == "xn" ] || \
               [ "x$yn" == "xno" ] || \
               [ "x$yn" == "xN" ] || \
               [ "x$yn" == "xNo" ] || \
               [ "x$yn" == "xNO" ] || \
               [[ "x$yn" == "x" && $# -eq 2 && $2 == "n" ]] ; then
            return 1
        fi
        echo "Please answer yes or no" > /dev/stderr
    done
}

function promptoptions () {
    while true ; do
        read -p "$1 " opt
        if [ "x${opt}" == "x" ] ; then
            echo "$3"
            return
        fi
        if [[ "$2" =~ (^| )${opt}($| ) ]] ; then
            echo "${opt}"
            return
        fi
        echo "Invalid option" > /dev/stderr
    done
}

function strstr () {
    x="${1%%$2*}"
    [[ "$x" = "$1" ]] && echo -1 || echo ${#x}
}

function promptlist () {
    PROMPT="[$(echo "$1" | sed "s/\($2\)/\U\1/" | sed "s/./\0\\//g" | \
               head -c -2)] "
    while true ; do
        read -p "$PROMPT" opt
        if [ ${#opt} -eq 0 ] ; then
            opt=$2
        fi
        if [ ${#opt} -eq 1 ] ; then
            # downcase
            opt=${opt,,}
            if [[ $1 == *"$opt"* ]] ; then
                echo $opt
                return
            fi
        fi
        echo "?" > /dev/stderr
    done
}

function OK () {
    echo -e "[\x1b[32mOK\x1b[m] $@"
}

function ERR () {
    __ERROR=true
    echo -e "[\x1b[31mEE\x1b[m] $@"
}

function WARN () {
    echo -e "[\x1b[33m!!\x1b[m] $@"
}

function INFO () {
    summary="$1"
    shift
    echo -e "[\x1b[34m${summary}\x1b[m] $@"
}

function plural () {
    echo -n "$1"
    if [ $2 -ne 1 ] ; then
        echo -n s
    fi
}

function require () {
    echo "Checking for required packages"
    for pkg in $@ ; do
        if dpkg --status $pkg >/dev/null 2>&1 ; then
            OK $pkg
        else
            INFO Installing $pkg
            run sudo apt-get -y install --no-install-recommends $pkg
        fi
    done
}

function installed () {
    for x in $@ ; do
        if ! which $x >/dev/null ; then
            return 1
        fi
    done
    return 0
}

function prompt_install () {
    prog=$1
    if [ $# -eq 2 ] ; then
        name=$2
    else
        name=$prog
    fi
    if installed $prog ; then
        OK $name
        exit 0
    fi
    # The user already agreed to run this step, so don't ask again
    [ "$ASK_STEP" = true ] && return 0
    # The user ran the step directly which shows intent, so don't ask
    [ "$0" = "$BASH_SOURCE" ] || return 0
    promptyn "\`$name' is not installed; Install now?" "y" || exit 0
    return 0
}

function prompt_step () {
    # The user already agreed to run this step, so don't ask again
    [ "$ASK_STEP" = true ] && return 0
    promptyn "$1" "$2" || exit 0
    return 0
}

function goto_tempdir () {
    DIR="/tmp/install-$STEP"
    CLEAN="rm -rf $DIR 2>/dev/null || sudo rm -rf $DIR"
    eval $CLEAN
    mkdir $DIR
    run cd $DIR
    # update exit handler to clean up
    trap "$CLEAN;__finish" EXIT
}



# Run this when sourced

# Print the current step
STEP="$(basename "$0")"
STEP="${STEP%.*}"
STEP_FILE="$(realpath "$0")"
echo -en "  \x1b[33m<<\x1b[m $STEP "
[ "$SIMULATE" = true ] && echo -n "(SIMULATION) "
echo -e "\x1b[33m>>\x1b[m"

if [ "$ASK_STEP" = true ] ; then
    promptyn "Run step \`$STEP'?" "y" || exit 0
fi

# Invariant:  we're in home at the beginning of each step
cd

# Be sure to have the latest and greatest PATH
[ -f ~/.profile ] && . ~/.profile

true
